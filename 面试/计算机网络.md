## 书籍推荐
- 图解HTTP
## 问题

### 1.TCP协议如何确保可靠性
TCP的三次握手策略
>握手过程中某个阶段异常中断后，TCP协议会再次以相同的顺序发送相同的数据包
- 握手前发送端的状态是closed，接收端的状态是listen。
- 第一次握手：发送端首先发送一个SYN码数据包给接收端，此时发送端的状态是SYN_SEND。
- 第二次握手：接收端收到后回传SYN/ACK码数据包给发送端，接收端处于SYN_REVD状态，接收端将这种状态的请求放到一个队列里，称为半连接队列。
- 第三次握手：发送端确认后再次回传ACK码给接收端，发送端处于establised状态。
- 接收端收到ACK码后，也处于established状态，此时，双方的连接建立，接收端将这种状态的请求放入全连接队列中。

三次握手过程中可以携带数据吗

> 第三次握手可以携带数据

### 2.http报文结构
结构
- 报文首部
- 空行（回车符+换行符）
- 报文主体

请求报文首部
- 请求行
- 请求首部字段
- 通用首部字段
- 实体首部字段
- 其他

响应报文首部
- 状态行
- 响应首部字段
- 通用首部字段
- 实体首部字段
- 其他

### 3.ssl的安全通信机制
> HTTPS并非应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。
- 客户端首先发送SSL请求报文
- 服务端收到请求后发送证书报文
- 客户端验证证书有效性，产生随机密码串，发送带有密码串报文并使用证书公钥进行加密
- 客户端继续发送报文，通知服务端此后的报文采用随机密码串进行加密
- 客户端发送Finish报文
- 服务端收到报文后，首先通过私钥解密获取随机密码串，然后通知客户端此后的报文通信采用随机密码串进行加密
- 服务端随后发送Finish报文
- 双方的ssl连接建立完成，此后开始进行应用层协议的通信

### 4.websocket的通信机制

> 由于HTTP协议上的限制以及自身性能有限，需要一种全新的协议来突破它的性能瓶颈，SPDY协议采用多路复用流，通过单一的TCP连接，可以无限个处理多个HTTP请求。但是spdy仅限于单个域名（IP地址）的通信多路复用。WebSocket协议采用全双工通信，服务端可以直接向客户端推送信息，而无需等待客户端的请求。

- 首先建立HTTP连接
- 客户端发送一次握手请求，修改HTTP头部中的Upgrade首部字段，告知服务器通信协议发生改变
- 服务端作出响应，并返回101 Switching Protocols的状态码，通知客户端已完成协议切换

### 5.http/2.0技术

> HTTP围绕着主要的7项技术进行讨论，目的在于改善用户在使用Web时的速度体验。其中包括SPDY和WebSocket

### 6.web的攻击手段

> 据统计，全球大约70%的Web应用攻击都来自XSS攻击和SQL注入攻击。此外，常见的Web攻击还包括CSRF、Session劫持等手段

**XSS攻击**

XSS攻击即跨站点脚本攻击（Cross Site Script），指攻击者通过篡改网页，注入恶意的HTML脚本，在用户浏览网页时，恶意的脚本显示在正常的网页中，从而控制用户浏览器进行恶意操作的一些行为。

常见的预防措施：消毒、HttpOnly

**SQL注入攻击**

SQL注入攻击，指攻击者在HTTP请求中注入恶意的SQL命令，服务器在用请求参数构造SQL命令的同时，恶意SQL也一同被构造，并在数据库中执行。

常见的预防措施：参数绑定、消毒，关闭错误回显

**CSRF攻击**

CSRF即跨站点伪造请求（Cross Site Request Forgery），攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易、发表评论等。其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。

常见的预防措施：表单Token、验证码、Referer Check



### 7.输入URL回车之后，究竟发生了什么

1. 格式校验和协议选择
2. DNS查询IP地址
3. 通过ARP协议得到MAC地址
4. 通过TCP协议三次握手确保可靠性传输

### 8.如何进行拥塞控制

> 两台主机在通过TCP协议传输数据包的时候，如果发送方迟迟没有收到接收方反馈的ACK，那么发送方就会认为它发送的数据包丢失了，进而会重新传输这个丢失的数据包。大量的重新传输会浪费信道资源，造成网络阻塞。
>
> 拥塞控制通过调整连接单次发送的分组数量来处理网络拥塞现象。如果单次发送量为1，此协议就退化为停等协议。

1. 当主机收到一条新确认时。若单次发送量小于倍增阀值，则单次发送量加倍，呈指数增长；否则加1，呈线性增长。
2. 当主机收到三条重复的确认，则单次发送量减半，倍增阀值等于单次发送量。
3. 当主机探测到超时，则倍增阀值=单次发送➗2，单次发送量等于1。

### 9.如何进行流量控制

> 双方在通信的时候，如果发送方的发送速率太快大于接收方，这时候接收方只能把处理不过来的数据存在缓存区里，如果缓存区满了发送方还在发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源。

接收方在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据。同时开启一个定时器，每隔一段时间就发送测试报文去询问接收方，是否可以继续发送数据，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。

### 10.FastCGI对CGI做了哪些提升

> CGI是一种Web服务器与请求处理程序之间的一种协议。Web服务器和CGI程序通过环境变量、标准输入、标准输出进行通信。
>
> 有了协议规范，那么就有对应的实现。Web服务器的实现是通过安装对应的扩展包来实现的，比如Nginx的mod_fastcgi； 而另一端的web程序则需要一个fastCGI进程管理器来管理，这样的话才能在fastCGI初始化的时候就把各个处理程序给启动起来，等着web服务器发来的CGI请求，来一个就交给一个程序处理。
>
> CGI模式下，每次处理用户请求，都必须经历fork cgi进程、销毁cgi进程，一系列的I/O开销降低了网络的吞吐量。
>
> 注：使用PHP、Python开发Web应用时，如果不用语言内置的Web服务器，就必须涉及到如何与Web服务器通信，通信就需要协议。所以本质上，PHP、Python、C++都是一样的。CGI不是C++的专利。CGI程序可能是个C++编写的cgi程序，也可能是PHP、Python解释器。

FastCGI处理流程：

1. Web 服务器启动时载入初始化FastCGI执行环境 。 例如 `IIS ISAPI`、`apache mod_fastcgi`、`nginx ngx_http_fastcgi_module`、`lighttpd mod_fastcgi`
2. FastCGI进程管理器(例如跟PHP配合的FPM)自身初始化，启动多个CGI解释器进程并等待来自Web 服务器的连接。启动FastCGI进程时，可以配置以TCP socket和unix socket两种方式启动。

3. 当客户端请求到达Web 服务器时， Web 服务器将请求采用socket方式转发到 FastCGI主进程，FastCGI主进程选择并连接到一个CGI解释器（如果是C++写的就不是解释器了，而是C++的CGI程序）。Web 服务器将CGI环境变量和标准输入发送到FastCGI子进程。
4. FastCGI子进程完成处理后将标准输出和错误信息从同一socket连接返回Web服务器。当FastCGI子进程关闭连接时，请求便处理完成。
5. FastCGI子进程接着等待并处理来自Web 服务器的下一个连接。

FastCGI具有的优势：

1. 常驻进程，不需要花时间去fork，提高了吞吐量
2. 通过socket通信，支持分布式部署
