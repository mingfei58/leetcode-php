## 书籍推荐
- 现代操作系统 原书第四版

## 问题
### 1.进程之间通信的方式
1. 管道

> 管道是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称pipe文件
>
> - 当一个进程正在对pipe进行读/写操作时，另一个进程必须等待。
> - 写进程把数据写入pipe后，进入睡眠等待，直到读进程从pipe取走数据再唤醒它。
> - 读进程读到空pipe时，也会睡眠等待，直到写进程把数据写入pipe后才唤醒它。

- 消息队列
> 消息队列无需等待就能立刻返回，但是数据特别占用内存时，拷贝期间比较耗时。

- 共享内存
> 共享内存通过进程之间的虚拟内存映射至相同的物理内存来实现内存共享，这种需要解决多进程竞争内存资源的问题。

- 信号量
> 信号量是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的⼀种通信⽅式。

- Socket
> socket主要用来解决远程之间的通信问题

### 2.如何理解进程、线程、协程

1.需要多线程的理由

> - 并行的实体需要拥有同一个地址空间和所有可用数据的能力，这种能力是多进程模型所无法表达的
> - 新建一个进程需要的资源包括：全局变量、地址空间、信号和信号处理程序、定时器、打开文件等，新建一个线程需要程序计数器、寄存器、堆栈、状态，线程作为更轻量级的迷你进程，更容易被创建、撤销
> - 涉及大量I/O处理和计算时，多线程可以让这些活动彼此重叠进行，加快应用程序执行的速度
> - 多CPU系统中，多线程可以实现真正的并行
> 

2.需要协程的理由

>- 协程占用更低的内存空间，涉及大量的I/O处理和计算时更占据优势
>- 协程比线程更轻量级，更容易被创建、撤销
>- 可以很轻松的实现并发编程，避免复杂的异步回调逻辑，以及多线程锁机制

3.协程是如何实现的，和线程调度有什么区别吗

> 线程调度通常指的是内核级线程，内核赋予线程时间片，如果超过了时间片就会强制挂起该线程，线程在阻塞时会切换到其他已就绪的线程，线程调度算法最常用的是轮转调度和优先级调度。
>
> 协程调度属于非抢占式调度，协程提供了任务中断自身的方法，然后把控制交回给协程调度器，任务和调度器之间可以互相通信，于是便可以实现多任务协作，处理器需要在不同的任务之间进行切换，而且总是让每个任务运行一小会儿，协程调度算法采用的是GMP模型
>
> 协程实现并发的原因是它能用在套接字的监听上，每当有新连接要建立的时候，它会创建一个新任务来处理连接，可是套接字的操作一般都是阻塞的，要实现非阻塞I/O还必须确保套接字读写之前该套接字已经准备就绪，一般采用I/O多路复用模型去实现。

### 3.如何理解死锁（死锁预防、死锁检测与恢复、死锁避免）

> 死锁产生的四个必要条件：
>
> - 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
> - 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
> - 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。
> - 环路等待条件。死锁发生时，系统中一定有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。
>
> 以上四个条件一定是同时满足的，如果其中任何一个条件不成立，死锁就不会发生。

**死锁预防**

1. 破坏互斥条件。允许资源被多个进程所占用。
2. 破坏占有和等待条件。禁止已占有资源的进程再等待其他资源，系统提前请求所有资源，如果进程需要的全部资源都可用就分配，否则就不分配，进程等待。
3. 破坏不可抢占条件。允许已被进程占有的资源被其他进程抢占。
4. 破坏环路等待条件。将所有资源统一编号，顺序执行。

**死锁检测与恢复**

通过死锁检测算法进行穷举、遍历，如果检测到有环的存在，证明系统中存在死锁，否则不存在。

死锁的恢复方法包括：利用抢占恢复，利用回滚恢复，利用杀死进程恢复

**死锁避免**

银行家算法是一个避免死锁产生的算法，以银行借款分配策略为基础，通过了解系统中总的资源，已经分配的资源和未来需求的资源量来判断并保证系统处于安全状态。

银行家对应操作系统

资金对应资源

客户对应申请资源的线程