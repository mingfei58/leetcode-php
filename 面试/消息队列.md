## 书籍推荐

- RabbitMQ 实战指南

## 问题

### 1.解释RabbitMQ信道、交换器、路由键、绑定键、TTL、死信队列、延迟队列、优先级队列

**信道**

信道Channel可以用来接收和发送消息，每个Connection 可以创建多个Channel实例，Channel 不能在线程间共享，引入信道的目的是为了TCP连接复用，减少性能开销

**交换器**

生产者可以通过交换器将消息投递到队列中，交换器的类型有：anout, direct , topic, headers 这四种

**路由键**

在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时，通过指定路由键来决定消息流向哪里

**绑定键**

在某些交换器类型下，生产者将消息发送给交换器时，需要匹配绑定键和路由键，匹配成功后消息会被路由到对应的队列中

**TTL**

过期时间，一旦消息在队列中的生存时间超过了设置的TTL，就会变成死信

**死信队列**

当消息在一个队列中变成死信时，它会重新发送到一个DLX（死信交换器）中，绑定DLX的队列称为死信队列

**延迟队列**

消息被发送之后，并不希望消费者立即拿到这个消息进行消费，而是等待特定的时间之后才会执行。RabbitMQ可以借助TTL和DLX来模拟延迟队列的功能

**优先级队列**

优先级高的消息具备优先被消费的特权，这个情况只有当消费者的消费速度小于生产者的生产速度时才有实际意义

### 2.RabbitMQ的运转流程

**生产者发送消息的过程**

1. 生产者连接到 RabbitMQ Broker 建立一个连接( Connection) ，开启一个信道 (Channel)
2. 生产者声明一个交换器 ，并设置相关属性，比如交换机类型、是否持久化等，声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等
3. 生产者通过路由键将交换器和队列绑定起来
4. 生产者发送消息至 RabbitMQ Broker ，其中包含路由键、交换器等信息
5. 相应的交换器根据接收到的路由键查找相匹配的队列
6. 如果找到 ，则将从生产者发送过来的消息存入相应的队列中
7. 如果没有找到 ，则根据生产者配置的属性选择丢弃还是回退给生产者
8. 关闭信道
9. 关闭连接

**消费者消费消息的过程**

1. 消费者连接到 RabbitMQ Broker ，建立一个连接(Connection） ，开启一个信道(Channel)
2. 消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做些准备工作
3. 等待 RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息
4. 消费者确认 ack 接收到的消息
5. RabbitMQ 从队列中删除相应己经被确认的消息
6. 关闭信道
7. 关闭连接

### 3.如何避免消息不被重复消费

> 消费者在消费完一条消息之后向 RabbitMQ 发送确认 ack 命令，由于网络断开或者其他原因造成 RabbitMQ并没有收到这个确认命令，RabbitMQ 不会将此条消息标记删除，下次重新建立连接后，消费者还是会消费到这条消息
>
> 生产者在使用publisher confirm 机制的时候，发送完条消息等待 RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送

去重处理一般是在业务客户端实现，比如引入 GUID (Globally Unique Identifier) 的概念，保证幂等性设计

### 4.如何保证消息的可靠性传输

1. 消费生产者开启事务机制或者 publisher confirm机制
2. 消息生产者需要配合使用 mandatory 参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃
3. 消息和队列都需要进行持久化处理
4. 消费者在消费消息的同时需要将 autoAck 设置为 false ，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。

### 5.如何保证消息的顺序性

> 如果 个队列按照前后顺序分有 m1、m2、m3、m4个消息，同时有 a 和 b 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，a中的消息为 m1、m3，b 中的消息为 m2、m4，a 收到消息 m1 之后并不想处理而将消息拒绝，与此同时将requeue 设置为 true ，这样这条消息就可以重新存入队列中，消息 m1 之后被发送到了b 中，此时 b 己经消费了 m2、m4 ，之后再消费 m3，这样消息顺序性也就错乱了

为了保证消息的顺序性，需要业务客户端使用RabbitMQ之后做进一步的处理，比如在消息体内添加全局有序标识（Sequence ID）来实现

### 6.大量消息在MQ里长时间积压，如何解决

> 一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来

1. 紧急修复消费者服务，确保其恢复消费速度
2. 将交换器类型临时扩容，临时建立扩容后的队列
3. 写一个脚本，将积压的数据写入扩容的队列中
4. 临时扩容消费者服务，提升消费速度
5. 等积压的数据消费完成后，恢复原先的架构

### 7.MQ中的消息过期失效了怎么办？

批量重导，将丢失的那批数据，一点一点的查出来，然后重新添加到MQ中进行补发