## 书籍推荐

- Redis开发与运维

## 问题

### 1.Redis有哪些特性（为什么使用Redis）

1.速度快

> Redis是集性能与优雅于一身的开源代码，它是采用C语言编写的单线程架构，离操作系统更近，Redis所有数据都是存放在内存中的。

2.基于键值对的数据结构服务器

> Redis的值不仅可以是字符串，也可以是具体的数据结构，其中包括5种基本数据结构：字符串、哈希、列表、集合、有序集合，另外在字符串基础上演化了位图（Bitmaps）和HyperLogLog两种数据结构，在有序集合的基础上演化了GEO数据结构。
>
> 对于留存量比较大的数据，Bitmaps能节省很多的内存空间，比如网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户可以发现Bitmaps能减少很多的内存消耗。
>
> HyperLogLog采用的基数估算算法，相比于集合类型，HyperLogLog内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是100%的正确，其中一定存在误差率。Redis官方给出的数字是0.81%的失误率。
>
> GEO支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。

3.丰富的功能

>- 提供了键过期功能，用来实现缓存
>- 提供了发布/订阅功能，用来实现消息系统
>- 支持Lua脚本，自定义Redis命令
>- 提供了事务功能，保证了数据一致性
>- 提供了流水线（Pipeline）功能，用来批处理命令，减少网络开销
>
>Redis的发布/订阅无法和专业的消息队列系统（如Kafka、RocketMQ）进行比较，它无法实现消息堆积和回溯。

4.简单稳定

>源码简洁，单线程模型，无论是服务端还是客户端都很简单易用，不依赖于像libevent这样的系统类库，虽然简单，但是却十分稳定。

5.客户端语言多

> Redis提供了简单的TCP通信协议，支持Redis客户端的语言非常多，比如：Java、PHP、C、C++、Python、Nodejs等。

6.持久化

> Redis提供了两种实现持久化的方式RDB和AOF来保障数据的安全。
>
> RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发，无论手动还是自动，底层都是经过bgsave命令执行的，bgsave命令的运作流程如下：
>
> - 执行bgsave命令，父进程判断是否存在RDB/AOF子进程，如果存在则直接返回；
> - 如果不存在，父进程fork出子进程，bgsave命令返回“Background saving started”信息，并不再阻塞父进程，继续响应其他命令；
> - 子进程创建RDB文件，根据父进程共享内存生成临时快照文件，完成后对原有文件进行替换；
> - 子进程发送信号给父进程表示完成，父进程更新统计信息。
>
> AOF持久化以独立日志的方式记录每次写命令，重启后再重新执行AOF文件中的命令达到恢复数据的目的，AOF解决了RDB无法实时持久化/秒级持久化的缺陷，AOF持久化的运作流程如下：
>
> - 所有的命令会追加到aof缓冲区；
> - aof缓冲区同步写入硬盘，生成aof文件；
> - 定期对aof文件重写，以达到压缩文件的目的；
> - Redis服务器重启时，加载aof文件进行数据恢复

7.主从复制

8.高可用和分布式

### 2.Redis使用场景有哪些

1. 缓存

2. 计数器应用

3. 共享session
4. 消息队列
5. 社交网络
6. 排行榜系统

### 3.Redis阻塞后怎么办

> 客户端最先感知阻塞等Redis超时行为，加入日志监控报警工具可快速定位阻塞问题，同时需要对Redis进程和机器做全面监控。
>
> 阻塞的内在原因：确认主线程是否存在阻塞，检查慢查询等信息，发现不合理使用API或数据结构的情况，如keys、sort、hgetall等。关注CPU使用率防止单核跑满。当硬盘IO资源紧张时，AOF追加也会阻塞主线程
>
> 阻塞的外在原因：从CPU竞争、内存交换、网络问题等方面入手排查是否因为系统层面问题引起阻塞。

1.内在原因

（1）API或数据结构使用不合理

> 对一个包含上万个元素的hash结构执行hgetall操作，由于数据量比较大且命令算法复杂度是 O（n），这条命令执行速度必然很慢。

执行slowlog get{n}命令可以获取最近的n条慢查询命令

（2）CPU饱和

> 单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis把单核CPU使用率跑到接近100%

服务集群化，分摊OPS压力

（3）持久化阻塞

> 使用RDB持久化时，Redis主线程调用fork操作产生共享内存的子进程，由子进程完成持久化文件重写工作，如果fork操作本身耗时过长，必然会导致主线程阻塞。
>
> 使用AOF持久化时，aof文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作，当硬盘压力过大时，fsync操作需要等待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了数据安全性它会阻塞直到后台线程执行fsync操作完成。

如果是fork阻塞，避免使用过大的内存实例，如果是AOF刷盘阻塞，优化系统硬盘

2.外在原因

（1）CPU竞争

> Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis吞吐量。
>
> 对于开启了持久化或参与复制的主节点绑定CPU，子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。

通过top、sar等命令定位到CPU消耗的时间点和具体进程，对于开启了持久化或参与复制的主节点不建议绑定CPU。

（2）内存交换

> 内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存 
>
> 换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降。

检查Redis内存交换`redis-cli -p [port] info server | grep process_id `和`cat /proc/[process_id]/smaps | grep Swap `

（3）网络问题

> 网络问题经常是引起Redis阻塞的问题点。常见的网络问题主要有：连接拒绝、网络延迟、网卡软中断等。

使用连接池、增加带宽

### 4.Redis为什么对一种数据结构实现多种编码方式

​	通过不同的编码平衡算法，达到空间和效率的平衡，比如当我们的存储只有10个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要：前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表（ziplist），将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为O（n2）性能也可满足需求。

### 5.缓存穿透、缓存雪崩、缓存热点key重建优化

1.缓存穿透

> 缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，由于数据不写入缓存层导致每次请求都要到存储层去查询。

缓存空对象或者布隆过滤器拦截

2.缓存雪崩

> 由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。

保障缓存层服务高可用，使用隔离组件为后端限流或降级，提前演练

3.缓存热点key重建

> 在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。

分布式锁