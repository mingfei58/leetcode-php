## 书籍推荐

- MySQL技术内幕InnoDB存储引擎

## 问题

### 1.为什么MySQL数据库要用B+树存储索引

> B树是多路搜索树，它的每个节点可以拥有多于两个孩子节点。设计多路的目的是为了降低进一步降低平衡树的高度。
>
> 文件系统和数据库的索引都是存在磁盘上的，并且如果数据量大的话，不一定能一次加载到内存中，B数的魅力在于它可以分批载入内存。
>
> B+树在B树的基础上进行改造，它的叶子结点可以存放数据，同时叶子结点之间还加了指针形成链表。

这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

### 2.一条SQL语句执行得很慢的原因有哪些

> 当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在**内存**中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到**磁盘**中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到**磁盘**中去。
>
> 分析是否有遇到锁阻塞，可以根据 **INNODB_TRX**、**INNODB_LOCKS**、**INNODB_LOCK_WAITS** 这三张表来判断，INNODB_TRX 显示了当前正在运行的事务，INNODB_LOCKS 显示了当前的锁信息，INNODB_LOCK_WAITS 反应了当前的等待。
>
> 使用**非聚集索引**时，系统是有可能走全表扫描而不走索引的，系统是通过**索引的区分度**来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高，区分度低的走全表扫描，但是系统的这种判断机制是采样式的，并不能保证完全正确。

1. 大多数情况下很正常，偶尔很慢，则有如下原因
   - 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
   - 执行的时候，遇到锁，如表锁、行锁。

2. 这条 SQL 语句一直执行的很慢，则有如下原因
   - 没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。
   - 数据库选错了索引。