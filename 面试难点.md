## 双指针
1.输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

示例 :
``` 
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```
```php
/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val) { $this->val = $val; }
 * }
 */
class Solution {

    /**
     * @param ListNode $head
     * @param Integer $k
     * @return ListNode
     */
    function getKthFromEnd($head, $k) {
        $l1 = $l2 = $head;
        while($k>0 && $l1->next){
            $l1 = $l1->next;
            $k--;
        }
        while($l1->next){
            $l1 = $l1->next;
            $l2 = $l2->next;
        }
        return $l2->next;

    }
}
```

2.输入两个链表，找出它们的第一个公共节点。
示例1 ：
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 
```
示例2 ：
``` 
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```
示例3 ：
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。 
```
注意：
- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。


```php
/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val) { $this->val = $val; }
 * }
 */
class Solution {

    /**
     * @param ListNode $head
     * @param ListNode $headB
     */
    function getIntersectionNode($headA, $headB) {
        $l1 = $headA;
        $l2 = $headB;
        $over1 = false;
        $over2 = false;
        while(true){
            if($l1->next === null){
                $over1 = true;
                $l1 = $headB;
            }
            if($l2->next === null){
                $over2 = true;
                $l2 = $headA;
            }
            if($over1 && $over2 && $l1 === $l2){
                break;
            }
            $l1 = $l1->next;
            $l2 = $l2->next;
        }
        return $l1;
    }
}
```

3.输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例1 ：
```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```
示例2 ：
``` 
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```
限制：
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^6

```php
class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[]
     */
    function twoSum($nums, $target) {
        $len = count($nums);
        $i = 0;
        $j = $len-1;
        while ($i<$j){
            $sum = $nums[$i] + $nums[$j];
            if($sum>$target){
                $j--;
            }
            if($sum == $target){
                break;
            }
            if($sum<$target){
                $i++;
            }
        }
        if($nums[$i] + $nums[$j] == $target){
            return [$nums[$i],$nums[$j]];
        }
        return [];
    }
}
```


## 动态规划
1.一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例1 ：
```
输入：n = 2
输出：2
```
示例2 ：
``` 
输入：n = 7
输出：21
```
示例3 ：
``` 
输入：n = 0
输出：1
```
提示：
- 0 <= n <= 100
```php
class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function numWays($n) {
        $dp[1] = 1;
        $dp[2] = 2;
        if($n<=2){
            return $dp[$n]??1;
        }
        for($i=3;$i<=$n;$i++){
            $dp[$i] = $dp[$i-1] + $dp[$i-2];
        }
        return $dp[$n];
    }
} 
```

2.输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求：
- 时间复杂度为O(n)。

示例 ：
``` 
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
提示：
- 1 <= arr.length <= 10^5
- -100 <= arr[i] <= 100

```php
class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxSubArray($nums) {
        $len=count($nums);
        if($len==0){
            return 0;
        }
        $dp = [];
        $dp[0] = $nums[0];
        for($i=1;$i<$len;$i++){
            if($dp[$i-1]>0){
                $dp[$i] = $nums[$i] + $dp[$i-1];            
            }else{
                $dp[$i] = $nums[$i];
            }
        }
        return max($dp);

    }
}
```

3.给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
示例 ：
``` 
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```
提示：
- 0 <= num < 2^31
```php
class Solution {

    /**
     * @param Integer $num
     * @return Integer
     */
    function translateNum($num) {
        $len = strlen($num);
        if($len==0){
            return 1;
        }
        $dp[0] = 1;
        $dp[-1] = 1;
        for ($i=1;$i<$len;$i++){
            if($num[$i-1] == 1 || ($num[$i-1] == 2 && $num[$i]<=5)){
                $dp[$i] = $dp[$i-1] + $dp[$i-2];
            }else{
                $dp[$i] = $dp[$i-1];
            }
        }
        return $dp[$len-1];
    }
}
```


4.在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例：
```
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 
```
提示：
- 0 < grid.length <= 200
- 0 < grid[0].length <= 200
```php
class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function maxValue($grid) {
        $dp = [];
        $l1 = count($grid);
        $l2 = count($grid[0]);
        for($i=0;$i<$l1;$i++){
            for ($j=0;$j<$l2;$j++){
                if($i == 0 && $j == 0) $dp[$i][$j] = 0;
                if($i == 0){
                    $dp[$i][$j] = $dp[0][$j-1] + $grid[0][$j];
                }
                if($j == 0){
                    $dp[$i][$j] = $dp[$i-1][0] + $grid[$i][0];
                }
                if($i > 0 && $j > 0){
                    $dp[$i][$j] = $dp[$i-1][$j]>$dp[$i][$j-1]?$dp[$i-1][$j]+$grid[$i][$j]:$dp[$i][$j-1] + $grid[$i][$j];
                }
            }
        }
        return $dp[$l1-1][$l2-1];
    }
}
```
## 哈希冲突
1. hashMap的实现原理

   > hashMap是由数组加链表构成的，数组是hashMap的主体，链表是为了解决哈希冲突而存在的
   > 
   > hashMap的最快寻址是O(1)，这是因为仅需要通过哈希函数确定数组的位置后就能得到预期结果，使用哈希函数无法避免会出现哈希冲突，解决冲突的办法就是将数组Entry向外延伸，构造成一个链表结构，此时寻址的时间复杂度变为O(n)（n代表链表的长度）
2. 为什么hashMap的长度一定是2的次幂
   > 哈希函数计算出哈希值，还需要经过一些复杂的位运算，定位到数组下标的索引值，为了保证数组扩容后新旧索引不会有太大差异，hashMap的长度一定是2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。
   > 
   > 数组长度为2的次幂，还可以保证获得的数组索引index分布的更加均匀
## 跳跃表
1. skipList的实现原理
   > 跳跃表是一种有序的数据结构，他是通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的
   > 
   > 跳跃表采用空间换时间的设计思想，最大层级决定了跳表的最大层数（头指针和空指针必包含最大层级），当前层级k存在k个指向下个节点的指针，所有链表的元素都是有序排列的
   > 
   > 跳表的平均时间复杂度为O(logn)，平均空间复杂度为O(logn)
2. Redis使用跳跃表实现场景
   > Redis有序集合的内部编码实现有两种，ziplist和skiplist，当有序集合的元素的个数大于默认配置的最大值，或者其中某个元素的长度大于默认设置的最大字节时，有序集合会采用skiplist作为内部实现
## I/O多路复用
1. 对比评估一下阻塞I/O和I/O多路复用的性能
   > 如果一个进程要等待多种不同的消息，采用阻塞I/O的方式是开启多线程，每个线程在消息产生的时候就会阻塞，而I/O复用则是采用select,poll,epoll的方法，直接在进程中监听所有的消息类型。
   > 
   > 可以将select复用机制看作是一个描述符集合的管理，进程通过向这个集合中放入不同的描述符，用来等待不同的消息产生，然后通过select统一的进行管理，让其可以同时等待这个集合中的任意一个事件的产生
   > 
   > 可以看出，I/O复用等待多类事件，阻塞式I/O只等待一类事件，另外，在I/O复用中，会产生两个系统调用（如上图，select和recvfrom），而阻塞式I/O只产生一个系统调用(recvfrom)。那么这就涉及到具体的性能问题，当只存在一类事件的时候，使用阻塞式I/O模型的性能会更好，当存在多种不同类型的事件时，I/O复用的性能要好的多，因为阻塞式I/O模型只能监听一类事件，所以这个时候需要使用多线程进行处理。
2. workerman是如何实现非阻塞的
   > workerman采用Master/worker架构的进程模型，Master通过信号和事件机制来，负责管理和维护子进程，worker进程采用的是I/O复用模型，进程在stream_select阶段处于挂起状态，并等待套接字发生变化，处理TCP/UDP连接、READ、WRITE、CLOSE一系列事件类型
## 死锁
1. 形成死锁的必要条件
   >- 进程对于分配的资源具有排他性
   >- 进程因请求被占用资源发生阻塞是，对已持有的资源保持不放
   >- 进程在未释放资源之前，其他进程不能强行占用
   >- 相互竞争资源而互相阻塞的进程会形成一个环路，造成永久阻塞
2. 如何避免死锁
   >- 保持锁的有序性
   >- 超时处理
   >- 死锁检测
3. Redis分布式锁如何解决死锁问题
   > setnx,ttl,expire
4. MySQL使用Innodb引擎时如何减少死锁发生的概率
   >- 控制事务的大小，减少锁定的时间长度
   >- 合理的设计索引，尽可能的缩小锁定范围
   >- 相同类型的业务模块，按照同样的顺序进行事务处理
## 缓存穿透
1. 缓存穿透产生的原因，如何避免
   > 缓存的意义在于加速网页反应，保护存储层，当大量的请求访问某个不存在的资源时，由于缓存层未命中，且储存层拿不到数据而未对其进行缓存时，所有类似的请求都会越过缓存层直接到达存储层，增大存储层的并发量，从而有可能引发宕机的事故
   > 
   > 处理方式：1.布隆过滤器；2.缓存空对象
## 缓存重载
1. 缓存热点key重建有哪些问题
   > 在缓存失效的瞬间，有大量的线程来重建缓存，造成后端负载过大
   > 如何避免：分布式锁
##（非）聚簇索引
1. 聚簇索引和非聚簇索引的区别
   > 在Innodb下主键索引是聚集索引，在Myisam下主键索引是非聚集索引
   > 
   > 聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引；二级索引的叶子节点存放的是主键值或指向数据行的指针。
   > 
   > 由于叶子节点(数据页)只能按照一颗B+树排序，故一张表只能有一个聚簇索引。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引
## 三次握手四次挥手
1. 当在浏览器输入url，向服务器发送请求，浏览器都做了些什么？
   - http事务：
   >http请求阶段
   >- 浏览器将URL发送给DNS域名服务器
   >- DNS域名服务器根据IP找到应用服务器
   >- 服务器接受请求，与客户端建立了连接
   > 
   >http响应阶段
   >- 服务器通过路径定位到项目根目录
   >- 服务器先将一些响应信息放在响应头中，发送至客户端
   >- 将处理结果也发送给客户端，直到客户端接受完毕
   > 
   >浏览器渲染阶段
   >- 客户端接收完服务端的响应数据
   >- 浏览器通过DOM进行渲染和描绘
   - http三次握手：
   >- 浏览器发送给服务端SYN码，请求和服务端建立连接
   >- 服务端接收到SYN码后，再发送给客户端SYN+ACK码，确认建立连接
   >- 客户端接收到ACK码后，验证ACK是否正确，如果正确则建立和服务端的连接，双方的数据发送通道开启
   - http四次挥手：
   >- 当客户端无数据传输了，会发送FIN码到服务端，告知已发送完毕
   >- 当服务端接收到FIN码后，发送ACK码到客户端，告知客户端可以将数据通道关闭了
   >- 当服务端发送完毕后，也会发送FIN码到客户端，告知数据已发送完毕
   >- 当客户端接收到FIN码后，同样发送ACK码到服务端，告知服务端可以将数据通道关闭了
##（非）对称加密
1. https的加密过程
   >- 浏览器首先会验证数字证书的有效性（颁发机构和过期时间）
   >- 浏览器客户端产生随机值，并通过证书对其加密，发送给服务端
   >- 服务端接收到数据后，通过私钥进行解密，得到随机值，并根据随机值将响应数据进行对称加密
   >- 客户端根据随机值对其解密，获取响应的信息
## 连接池
1. 搭建连接池需要哪些要素([连接池实现过程](https://cloud.tencent.com/developer/article/1805844))
   > 连接池对外提供的接口
   > 获取连接
   > 归还连接
   > 连接池对内实现如下功能
   > 创建连接
   > 连接池配置（最大连接、最小空闲）
   > 可用连接
   > 已用连接
   > 连接保活
   > 空闲连接回收器
   > 可用性检测器
2. 基于swoole实现连接池
## 锁定机制
1. Innodb 事务隔离级别下锁定及死锁
   > 存在索引行锁定
   > 无索引表锁定
   > 间隙锁
## 搜索引擎
1. 什么时候使用全文搜索引擎
   >- 搜索的数据为大量的非结构化的文本数据
   >- 文件记录量达到数十万或数百万甚至更多
   >- 使用大量交互式的文本查询
   >- 需求非常灵活的全文搜索查询
## 流程引擎
1. 流程子系统的设计与实现
## 规则引擎
1. 规则引擎的设计与实现
## 进程通信
1. 进程之间通讯的方式有哪些
   >- 管道
   >- FIFO
   >- 消息队列
   >- 信号
   >- 共享内存
2. swoole进程通信的方式
   > 共享内存Table
## 协程
## 数据持久化
1. Redis实现数据持久化的方式
## ACID
1. ACID实现原理
   >- A:Atomic，通过Undo Log来保障事物的原子性
   >- C:Consistency，通过Undo Log来保障事物的一致性
   >- I:Isolation，通过锁机制来保障事物的隔离性
   >- D:Duration，通过Redo Log来保障事物的持久性
## CAP
1. 分布式事务的复杂性体现在哪些
   >- 存储端的多样性：事务中的数据可能会落到DB，或者Redis、MQ中
   >- 事务链路的复杂性：一个操作被拆分成多个服务，呈线状或网状，依靠网络通讯构成一个整体
2. CAP和ACID中AC的区别
   > CAP的C和ACID的C都表示一致性，不同的是前者表示分布式中各个节点的数据一致，后者表示数据库状态的一致
   > CAP的A表示Availability，分布式中一部分节点出现故障后，整体是否还能保证正常响应客户端的读写请求，后者表示事务是一个不可分割的最小单元，要么成功提交，要么失败回滚
## 深度学习